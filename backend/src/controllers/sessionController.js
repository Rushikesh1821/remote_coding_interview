import { chatClient, streamClient } from "../lib/stream.js";
import Session from "../models/Session.js";

export async function createSession(req, res) {
  try {
    // Only HOST can create sessions
    if (req.user.role !== "host") {
      return res.status(403).json({ 
        message: "Forbidden - Only hosts can create interview sessions" 
      });
    }

    const { problem, difficulty } = req.body;
    const userId = req.user._id;
    const clerkId = req.user.clerkId;

    if (!problem || !difficulty) {
      return res.status(400).json({ message: "Problem and difficulty are required" });
    }

    // generate a unique call id for stream video
    const callId = `session_${Date.now()}_${Math.random().toString(36).substring(7)}`;

    // create session in db with status "waiting" (sessionId is auto-generated by schema)
    const session = await Session.create({ 
      problem, 
      difficulty, 
      host: userId, 
      callId,
      status: "waiting"
    });
    
    // Ensure sessionId is set (should be auto-generated, but verify)
    if (!session.sessionId) {
      // This shouldn't happen, but if it does, log a warning
      console.warn("Session created without sessionId, this should not happen");
    }

    // create stream video call
    await streamClient.video.call("default", callId).getOrCreate({
      data: {
        created_by_id: clerkId,
        custom: { problem, difficulty, sessionId: session.sessionId },
      },
    });

    // chat messaging
    const channel = chatClient.channel("messaging", callId, {
      name: `${problem} Session`,
      created_by_id: clerkId,
      members: [clerkId],
    });

    await channel.create();

    res.status(201).json({ session });
  } catch (error) {
    console.log("Error in createSession controller:", error.message);
    res.status(500).json({ message: "Internal Server Error" });
  }
}

export async function getActiveSessions(req, res) {
  try {
    const userId = req.user?._id;
    const userRole = req.user?.role;

    if (!userId || !userRole) {
      return res.status(400).json({ message: "User ID and role are required" });
    }

    // Build query based on role - CRITICAL: Only show sessions where user participated in their current role
    // Filter out ended sessions - only show waiting and active sessions
    let query = { status: { $in: ["waiting", "active"] } };
    
    if (userRole === "host") {
      // Hosts see ONLY sessions where they are the host (waiting or active)
      query.host = userId;
    } else if (userRole === "participant") {
      // Participants see ONLY sessions where they are the participant (waiting or active)
      query.participant = userId;
    } else {
      // Unknown role - return empty array for security
      return res.status(200).json({ sessions: [] });
    }

    const sessions = await Session.find(query)
      .select("+sessionId") // Explicitly include sessionId (in case it's excluded)
      .populate("host", "name profileImage email clerkId")
      .populate("participant", "name profileImage email clerkId")
      .sort({ createdAt: -1 })
      .limit(20);

    // Ensure all sessions have sessionId (for backward compatibility)
    const sessionsWithId = sessions.map(session => {
      const sessionObj = session.toObject();
      // If sessionId is missing, it means the session was created before sessionId was added
      // In that case, we'll use _id as fallback (but log a warning)
      if (!sessionObj.sessionId && sessionObj._id) {
        console.warn(`Session ${sessionObj._id} missing sessionId, using _id as fallback`);
        // Note: We don't modify the DB here, just ensure the response has an identifier
      }
      return sessionObj;
    });

    res.status(200).json({ sessions: sessionsWithId });
  } catch (error) {
    console.log("Error in getActiveSessions controller:", error.message);
    res.status(500).json({ message: "Internal Server Error" });
  }
}

export async function getMyRecentSessions(req, res) {
  try {
    const userId = req.user?._id;
    const userRole = req.user?.role;

    if (!userId || !userRole) {
      return res.status(400).json({ message: "User ID and role are required" });
    }

    // Build query based on role - CRITICAL: Only show sessions where user participated in their current role
    let query = { status: "ended" };
    
    if (userRole === "host") {
      // Hosts see ONLY sessions where they were the host
      query.host = userId;
    } else if (userRole === "participant") {
      // Participants see ONLY sessions where they were the participant
      query.participant = userId;
    } else {
      // Unknown role - return empty array for security
      return res.status(200).json({ sessions: [] });
    }

    const sessions = await Session.find(query)
      .select("+sessionId") // Explicitly include sessionId
      .populate("host", "name profileImage email clerkId")
      .populate("participant", "name profileImage email clerkId")
      .sort({ createdAt: -1 })
      .limit(20);

    // Ensure all sessions have sessionId
    const sessionsWithId = sessions.map(session => session.toObject());

    res.status(200).json({ sessions: sessionsWithId });
  } catch (error) {
    console.log("Error in getMyRecentSessions controller:", error.message);
    res.status(500).json({ message: "Internal Server Error" });
  }
}

export async function getSessionById(req, res) {
  try {
    const { id } = req.params;
    const userId = req.user?._id;
    const userRole = req.user?.role;

    // Try to find by sessionId first (UUID), then fallback to MongoDB _id
    let session = await Session.findOne({ sessionId: id })
      .populate("host", "name email profileImage clerkId")
      .populate("participant", "name email profileImage clerkId");

    // If not found by sessionId, try MongoDB _id
    if (!session) {
      session = await Session.findById(id)
        .populate("host", "name email profileImage clerkId")
        .populate("participant", "name email profileImage clerkId");
    }

    if (!session) return res.status(404).json({ message: "Session not found" });

    // SECURITY: Validate user has access to this session based on their role
    // BUT: Allow participants to VIEW waiting/active sessions (for joining) even if not yet joined
    if (userId && userRole) {
      const isHost = session.host?._id?.toString() === userId.toString();
      const isParticipant = session.participant?._id?.toString() === userId.toString();
      const isWaitingOrActive = session.status === "waiting" || session.status === "active";
      const hasNoParticipant = !session.participant;

      if (userRole === "host") {
        // Hosts can only access sessions where they are the host
        if (!isHost) {
          return res.status(403).json({ 
            message: "Forbidden - You can only access sessions where you are the host" 
          });
        }
      } else if (userRole === "participant") {
        // Participants can access:
        // 1. Sessions where they are already the participant
        // 2. Waiting/active sessions with no participant yet (for joining)
        if (!isParticipant && !(isWaitingOrActive && hasNoParticipant)) {
          return res.status(403).json({ 
            message: "Forbidden - You can only access sessions where you are the participant or sessions available for joining" 
          });
        }
      }
    }

    res.status(200).json({ session });
  } catch (error) {
    console.log("Error in getSessionById controller:", error.message);
    res.status(500).json({ message: "Internal Server Error" });
  }
}

export async function joinSession(req, res) {
  try {
    // Only PARTICIPANT can join sessions (hosts create them)
    if (req.user.role !== "participant") {
      return res.status(403).json({ 
        message: "Forbidden - Only participants can join interview sessions" 
      });
    }

    const { id } = req.params;
    const userId = req.user._id;
    const clerkId = req.user.clerkId;

    // Try to find by sessionId first (UUID), then fallback to MongoDB _id
    let session = await Session.findOne({ sessionId: id });
    if (!session) {
      session = await Session.findById(id);
    }

    if (!session) return res.status(404).json({ message: "Session not found" });

    if (session.status === "ended") {
      return res.status(400).json({ message: "Session not found or expired" });
    }

    if (session.host.toString() === userId.toString()) {
      return res.status(400).json({ message: "Host cannot join their own session as participant" });
    }

    // check if session is already full - has a participant
    if (session.participant) return res.status(409).json({ message: "Session is full" });

    // Update session: add participant and change status to "active"
    session.participant = userId;
    if (session.status === "waiting") {
      session.status = "active";
    }
    await session.save();

    // Add participant to chat channel
    const channel = chatClient.channel("messaging", session.callId);
    await channel.addMembers([clerkId]);

    res.status(200).json({ session });
  } catch (error) {
    console.log("Error in joinSession controller:", error.message);
    res.status(500).json({ message: "Internal Server Error" });
  }
}

export async function endSession(req, res) {
  try {
    // Only HOST can end sessions
    if (req.user.role !== "host") {
      return res.status(403).json({ 
        message: "Forbidden - Only hosts can end interview sessions" 
      });
    }

    const { id } = req.params;
    const userId = req.user._id;

    const session = await Session.findById(id);

    if (!session) return res.status(404).json({ message: "Session not found" });

    // check if user is the host
    if (session.host.toString() !== userId.toString()) {
      return res.status(403).json({ message: "Only the host can end the session" });
    }

    // check if session is already ended
    if (session.status === "ended") {
      return res.status(400).json({ message: "Session is already ended" });
    }

    // delete stream video call
    const call = streamClient.video.call("default", session.callId);
    await call.delete({ hard: true });

    // delete stream chat channel
    const channel = chatClient.channel("messaging", session.callId);
    await channel.delete();

    session.status = "ended";
    await session.save();

    res.status(200).json({ session, message: "Session ended successfully" });
  } catch (error) {
    console.log("Error in endSession controller:", error.message);
    res.status(500).json({ message: "Internal Server Error" });
  }
}
